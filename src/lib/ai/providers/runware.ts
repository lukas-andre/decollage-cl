/**
 * Runware AI Provider
 * Fast virtual staging using Runware API
 */

import { v4 as uuidv4 } from 'uuid'
import type { ImageGenerationResult, AIProvider } from '../types'

interface RunwareConfig {
  apiKey: string
  apiUrl: string
  model: string
  maxPromptLength: number
  defaultCFGScale: number
}

interface RunwareUploadResponse {
  imageUUID: string
}

interface RunwareGenerationParams {
  seedImageUUID: string
  prompt: string
  numberOfImages?: number
  CFGScale?: number
  customStyle?: string
}

export class RunwareProvider {
  private config: RunwareConfig
  readonly provider: AIProvider = 'runware'

  constructor(config?: Partial<RunwareConfig>) {
    this.config = {
      apiKey: process.env.RUNWARE_API_KEY!,
      apiUrl: 'https://api.runware.ai/v1',
      model: 'bytedance:4@1',
      maxPromptLength: 500,
      defaultCFGScale: 7,
      ...config
    }

    if (!this.config.apiKey) {
      throw new Error('RUNWARE_API_KEY environment variable is required')
    }
  }

  /**
   * Upload an image to Runware
   */
  async uploadImage(imageDataUri: string): Promise<RunwareUploadResponse> {
    const taskUUID = uuidv4()

    const requestBody = [
      {
        taskType: 'authentication',
        apiKey: this.config.apiKey,
      },
      {
        taskType: 'imageUpload',
        taskUUID,
        image: imageDataUri,
      },
    ]

    const response = await fetch(this.config.apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
      signal: AbortSignal.timeout(30000),
    })

    if (!response.ok) {
      throw new Error(`Runware upload failed: ${response.status}`)
    }

    const data = await response.json()
    const uploadResult = data.data?.find(
      (item: { taskType: string; taskUUID: string; imageUUID?: string }) => 
        item.taskType === 'imageUpload' && item.taskUUID === taskUUID
    )

    if (!uploadResult?.imageUUID) {
      throw new Error('No imageUUID returned from Runware')
    }

    return { imageUUID: uploadResult.imageUUID }
  }

  /**
   * Generate image using image-to-image with custom style support
   */
  async generateImage(params: RunwareGenerationParams): Promise<ImageGenerationResult> {
    const startTime = Date.now()
    const taskUUID = uuidv4()

    // Apply custom style enhancements if provided
    let finalPrompt = params.prompt
    if (params.customStyle) {
      finalPrompt = this.applyCustomStyle(params.prompt, params.customStyle)
    }

    // Ensure prompt is under max length
    const trimmedPrompt = finalPrompt.substring(0, this.config.maxPromptLength)

    const requestBody = [
      {
        taskType: 'authentication',
        apiKey: this.config.apiKey,
      },
      {
        taskType: 'imageInference',
        numberResults: params.numberOfImages || 1,
        outputFormat: 'JPEG',
        CFGScale: params.CFGScale || this.config.defaultCFGScale,
        includeCost: true,
        outputType: ['URL'],
        referenceImages: [params.seedImageUUID],
        model: this.config.model,
        positivePrompt: trimmedPrompt,
        taskUUID,
      }
    ]

    const response = await fetch(this.config.apiUrl, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
      signal: AbortSignal.timeout(120000),
    })

    if (!response.ok) {
      throw new Error(`Runware generation failed: ${response.status}`)
    }

    const data = await response.json()
    const generatedImage = data.data?.find(
      (item: { taskType: string; imageURL?: string; cost?: number }) => 
        item.taskType === 'imageInference'
    )

    if (!generatedImage?.imageURL) {
      throw new Error('No image generated by Runware')
    }

    return {
      success: true,
      imageUrl: generatedImage.imageURL,
      cost: generatedImage.cost,
      provider: this.provider,
      model: this.config.model,
      processingTime: Date.now() - startTime,
    }
  }

  /**
   * Full staging pipeline
   */
  async generateStaging(
    imageFile: File,
    prompt: string,
    options?: { numberOfImages?: number; CFGScale?: number }
  ): Promise<ImageGenerationResult> {
    try {
      // Convert file to data URI
      const buffer = Buffer.from(await imageFile.arrayBuffer())
      const dataUri = `data:${imageFile.type};base64,${buffer.toString('base64')}`
      
      // Upload to Runware
      const { imageUUID } = await this.uploadImage(dataUri)
      
      // Generate staged image
      return await this.generateImage({
        seedImageUUID: imageUUID,
        prompt,
        ...options
      })
    } catch (error) {
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Runware generation failed',
        provider: this.provider,
        model: this.config.model,
        processingTime: 0,
      }
    }
  }

  /**
   * Test connection
   */
  async testConnection(): Promise<boolean> {
    try {
      // Create a tiny test image
      const { default: sharp } = await import('sharp')
      const testBuffer = await sharp({
        create: {
          width: 1,
          height: 1,
          channels: 3,
          background: { r: 255, g: 255, b: 255 }
        }
      }).jpeg().toBuffer()
      
      const dataUri = `data:image/jpeg;base64,${testBuffer.toString('base64')}`
      const { imageUUID } = await this.uploadImage(dataUri)
      return !!imageUUID
    } catch {
      return false
    }
  }

  /**
   * Apply custom style to prompt
   */
  private applyCustomStyle(basePrompt: string, styleTemplate: string): string {
    // Replace placeholders in style template
    let finalPrompt = styleTemplate
      .replace(/\{basePrompt\}/g, basePrompt)
      .replace(/\{quality\}/g, 'high quality, professional')
    
    // Add Runware-specific optimizations for better results
    finalPrompt += ' Photorealistic, high detail, professional staging.'
    
    return finalPrompt
  }

  /**
   * Enhance prompt for better results
   */
  private enhancePrompt(prompt: string): string {
    const enhancements = [
      'high quality',
      'professional staging',
      'photorealistic',
      'well-lit',
      'inviting atmosphere'
    ]
    
    return `${prompt}, ${enhancements.join(', ')}`
  }

  /**
   * Batch generation support
   */
  async generateBatch(
    images: File[],
    prompt: string,
    options?: {
      numberOfImages?: number
      CFGScale?: number
      customStyle?: string
    }
  ): Promise<ImageGenerationResult[]> {
    // Process images in parallel with rate limiting
    const batchSize = 3 // Process 3 at a time
    const results: ImageGenerationResult[] = []

    for (let i = 0; i < images.length; i += batchSize) {
      const batch = images.slice(i, i + batchSize)
      const batchResults = await Promise.all(
        batch.map(image => this.generateStaging(image, prompt, options))
      )
      results.push(...batchResults)
      
      // Small delay between batches
      if (i + batchSize < images.length) {
        await new Promise(resolve => setTimeout(resolve, 500))
      }
    }

    return results
  }

  /**
   * Get provider info
   */
  getInfo() {
    return {
      provider: this.provider,
      model: this.config.model,
      maxPromptLength: this.config.maxPromptLength,
      costPerImage: 0.04, // USD
      capabilities: [
        'image_to_image',
        'virtual_staging',
        'fast_generation',
        'custom_styles',
        'batch_processing',
        'interior_design'
      ],
      notes: 'Runware for fast, cost-effective staging',
      maxBatchSize: 3,
      estimatedProcessingTime: '10-20 seconds'
    }
  }
}