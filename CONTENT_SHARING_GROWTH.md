based on 
### M8: Content Sharing & Viral Growth 
**Status**: PENDING - Growth Engine
- **Favorites Widget**: Quick-access panel in project workspace
- **Share Preview**: Live preview of shareable content as you select favorites
- **One-Click Sharing**: Generate beautiful project showcases
- **Social Templates**: Instagram/Pinterest/WhatsApp formats
- **Public Project Pages**: Shareable URLs with OG meta tags
- **Privacy Controls**: Public/unlisted/private sharing options

AND 
Project Plan & Architectural Blueprint: Social Sharing and Content Distribution for Decollage.clStrategic Framework & Foundational ArchitectureThis document outlines the comprehensive architectural design and implementation plan for the Social Sharing Infrastructure and Content Distribution Architecture for Decollage.cl. The following sections detail the strategic vision, core technical decisions, and foundational schemas necessary to build a scalable, performant, and SEO-optimized platform on a Next.js, Supabase, and Cloudflare technology stack.A Unified Vision for Content at Decollage.cl: "Cada Creaci贸n, una Galer铆a"The foundational principle guiding this architecture is the strategic vision of treating every user's creation not as a transient entry in a feed, but as the centerpiece of its own dedicated micro-gallery. This philosophy, encapsulated by the motto "Cada Creaci贸n, una Galer铆a" (Every Creation, a Gallery), dictates that each piece of user-generated content deserves a unique, aesthetically pleasing, and highly shareable digital space. This approach elevates the user's work, fosters a sense of ownership and pride, and transforms the platform from a simple content repository into a curated showcase of creativity.This vision directly informs the technical requirements. It necessitates an architecture capable of programmatically generating an infinite number of unique, beautiful, and performant web pages. Each page must be a self-contained experience, dynamically themed to complement the artwork it features, and equipped with tools that encourage both social sharing and community engagement. By investing in this premium presentation layer, Decollage.cl can create a powerful flywheel effect: high-quality presentation encourages sharing, which drives traffic and new user acquisition, leading to more high-quality content creation.The Hybrid Rendering Model: Optimizing for SEO, Speed, and ScaleThe single most critical architectural decision for the platform's long-term success is the choice of rendering strategy. Given the dynamic nature of user-generated content and the stringent requirements for performance and SEO, a hybrid rendering model within Next.js is the optimal solution. This approach allows for per-page optimization, using the best rendering strategy for each specific use case.1An analysis of the primary rendering options reveals their respective limitations for this project. Pure Static Site Generation (SSG), while offering exceptional performance, is unsuitable because it requires a full site rebuild for every new piece of content, a process that is operationally infeasible at scale.2 Conversely, a pure Server-Side Rendering (SSR) model, where every page is generated on the server at request time, would place a significant and continuous load on the server infrastructure. This would lead to increased hosting costs and potentially slower server response times, which can negatively impact both user experience and SEO rankings.3The recommended architecture therefore adopts a nuanced, hybrid approach:Incremental Static Regeneration (ISR) for Content Pages: The auto-generated "Galer铆a de Creaci贸n" pages (e.g., /c/[creationId]) will be rendered using ISR. With ISR, the first time a specific creation's page is requested, Next.js will generate the page on the server, serve it to the user, and simultaneously cache a static HTML version at the edge via Cloudflare. All subsequent requests for that page will be served the lightning-fast, pre-rendered static file. A revalidate timer will be configured (e.g., every 60 minutes) to trigger a background regeneration of the page. This ensures that dynamic data, such as vote counts or comments, remains reasonably fresh without sacrificing the performance and scalability benefits of static hosting. This strategy perfectly balances the need for dynamic content with the SEO and speed advantages of pre-rendering.1Server-Side Rendering (SSR) for User-Centric Pages: Pages that display highly personalized and sensitive information, such as user dashboards, account settings, or private creation galleries, will utilize SSR. SSR generates the page on every request, ensuring that the data presented is always real-time and specific to the authenticated user.3 This is essential for security and for providing an accurate, up-to-the-moment user experience in private, authenticated sections of the application.This hybrid model leverages the full power of Next.js, transforming a potentially costly and slow dynamic content problem into a highly efficient and scalable static hosting problem, which is inherently cheaper, faster, and more resilient to traffic spikes.2Core Data Architecture in Supabase: A Schema for GrowthThe Supabase PostgreSQL database will serve as the single source of truth for the platform. The following schema is designed for relational integrity, performance, and extensibility, providing a solid foundation for the features outlined in this plan. It is structured to work seamlessly with Supabase's built-in features like Authentication, Storage, Row Level Security (RLS), and Realtime capabilities.5The schema will be managed declaratively using SQL migration files within the project repository, ensuring consistency between local development and production environments.6Key Database Tables:Table NameColumn NameData TypeConstraints / NotesusersiduuidPrimary Key. References auth.users.id.usernametextUnique, Not Null.avatar_urltextNullable. URL to user's profile picture.full_nametextNullable.created_attimestamptzNot Null. Default now().creationsiduuidPrimary Key. Default gen_random_uuid().user_iduuidForeign Key to users.id. Not Null.titletextNot Null.descriptiontextNullable.before_image_urltextNot Null. URL from Supabase Storage.after_image_urltextNot Null. URL from Supabase Storage.og_image_urltextNullable. URL of the pre-generated OG image.color_palettejsonbNullable. Stores { "vibrant": "#hex",... }.is_publicbooleanNot Null. Default true.created_attimestamptzNot Null. Default now().votesidbigintPrimary Key. Identity.creation_iduuidForeign Key to creations.id. Not Null.user_iduuidForeign Key to users.id. Not Null.created_attimestamptzNot Null. Default now().UNIQUE(creation_id, user_id) constraint.sharesiduuidPrimary Key. Default gen_random_uuid().creation_iduuidForeign Key to creations.id. Not Null.user_iduuidForeign Key to users.id. Nullable (for anonymous shares).platformtextNullable. e.g., 'twitter', 'whatsapp', 'copy_link'.created_attimestamptzNot Null. Default now().This schema provides the necessary relations to track creations, their authors, and the engagement they generate. The use of jsonb for color_palette allows for flexible storage of structured color data without requiring a separate table.5 The votes table is optimized for the simple, singular reaction mechanic ("Aplausos") and is designed to integrate directly with Supabase's Realtime engine for live updates.7Leveraging the Edge: The Role of CloudflareCloudflare will serve as a critical component of the infrastructure, acting as the global distribution and security layer in front of the Next.js application and Supabase backend. Its role extends beyond simple hosting to encompass performance optimization, security, and cost management.Global Caching and Content Delivery Network (CDN): Cloudflare's primary function will be to cache the ISR-generated static pages and all static assets (images, JavaScript, CSS) at its numerous edge locations around the world. This ensures that users, regardless of their geographic location, experience minimal latency and near-instant load times.4 This is particularly crucial for serving the high-resolution 'before' and 'after' images.Image Optimization: While Next.js provides the excellent next/image component for basic optimization, Cloudflare Images can further enhance this process. It can automatically resize images on the fly, compress them, and serve them in modern, efficient formats like WebP or AVIF to supported browsers. This reduces bandwidth consumption and accelerates page loads, a key factor in both user experience and SEO rankings.9Security: Cloudflare will provide a robust first line of defense for the entire application. Its Web Application Firewall (WAF) will protect against common web vulnerabilities, and its DDoS mitigation capabilities will ensure the platform remains available even during large-scale attacks. This secures both the Next.js frontend and the Supabase API endpoints from malicious traffic.By offloading traffic and security concerns to Cloudflare's edge network, the core application servers can focus on their primary tasks: generating pages and serving API requests, leading to a more stable, secure, and performant platform.Feature Deep Dive: The Social Sharing InfrastructureThis section details the features and technical implementations required to make content from Decollage.cl highly engaging and effective when shared across social media platforms, messaging apps, and the wider web.Dynamic Social Cards: "Tu Creaci贸n, Tu Tarjeta de Visita"The single most impactful feature for driving click-through rates and establishing brand presence on social media is the dynamic generation of rich, branded Open Graph (OG) images. When a user shares a link to a creation, the platform must provide a compelling visual previewa digital business card ("Tarjeta de Visita") for that creation.Technical Implementation:This will be achieved using Next.js's built-in support for dynamic OG image generation within the App Router.11Route Handler: A special file, opengraph-image.tsx, will be created within the dynamic route segment (e.g., app/c/[creationId]/opengraph-image.tsx). This file exports a function that Next.js will execute on the server to generate an image.Image Generation with ImageResponse: Inside this file, the ImageResponse constructor from the next/og library will be used. This powerful API allows for the rendering of a React component, written with standard JSX and a subset of CSS (primarily Flexbox), directly into a PNG image stream.11Dynamic Content: The exported function will receive the creationId from the URL parameters. It will use this ID to fetch the corresponding creation's data from Supabase (e.g., the 'after' image URL, title, and the author's username and avatar). This data will then be passed as props to a dedicated React component (e.g., <OGCardTemplate {...creationData} />).Branded Template: The OGCardTemplate component will be meticulously designed to align with Decollage.cl's brand guidelines. It will incorporate the brand's logo, fonts, and color scheme, and will artfully arrange the dynamic content to create a visually appealing and informative social card. This ensures brand consistency and a professional appearance for every shared link.13Scalability and Performance Strategy:Generating an image is a computationally intensive process. To prevent server overload if a piece of content goes viral and its OG image is requested thousands of times, a "generate-once, cache-forever" strategy will be implemented.Asynchronous Generation: Upon the successful creation of a new entry in the creations table, a Supabase Database Function (or Edge Function) will be triggered.Image Creation and Storage: This function will invoke a secure, internal API endpoint in the Next.js application. This endpoint's sole responsibility is to execute the ImageResponse logic and generate the OG image. The resulting image will be uploaded directly to Supabase Storage.URL Update: Once uploaded, the public URL of the newly created OG image in Supabase Storage will be written back to the og_image_url column in the corresponding creations table row.Static Serving: The generateMetadata function for the public creation page will then use this static, globally-cached og_image_url for the <meta property="og:image"> tag. This approach ensures that all subsequent share requests serve a static image file directly from the CDN, making the system incredibly resilient, scalable, and cost-effective.14Engagement Mechanics: "Reacciones que Inspiran"To foster a vibrant community and provide creators with positive feedback, a simple yet effective real-time reaction system will be implemented. Instead of a generic "like," this feature will be branded as "Aplausos" (Applause), aligning with the creative and celebratory nature of the platform.Database and Security:The foundation of this system is the votes table in Supabase, as defined in the core architecture. It will store a record for each unique user-creation pair. To prevent abuse, strict Row Level Security (RLS) policies will be enforced 7:An INSERT policy will allow authenticated users to add a vote for any creation, but only with their own user_id.A SELECT policy will allow all users (including anonymous ones) to read the vote counts.UPDATE and DELETE policies will be highly restrictive, perhaps only allowing a user to delete their own vote within a certain time frame.Real-Time Updates with Supabase Realtime:To provide an engaging, instantaneous user experience, the vote count will update in real-time for all viewers of a creation page without requiring a page refresh. This will be achieved using Supabase's highly efficient Realtime Broadcast functionality, avoiding the need for inefficient client-side polling.8Postgres Trigger: A trigger will be attached to the votes table. This trigger will fire after any INSERT or DELETE operation.Broadcast Function: The trigger will execute a PL/pgSQL function. This function will use the realtime.broadcast_changes() helper to send a payload over a private, specific channel. The channel name will be dynamically constructed based on the creation_id (e.g., creations-votes:${creation_id}). The payload will contain the new total vote count for that creation.Client-Side Subscription: On the Next.js creation page, the Supabase client library will be used to subscribe to the relevant channel for the creation being viewed. The component will listen for new broadcast events on this channel.UI Update: When a new message containing the updated vote count is received, the component's state will be updated, and the UI will re-render instantly to reflect the new "Aplausos" count. This creates a lively and interactive experience, encouraging users to participate.15Share Analytics & Link ManagementTo provide valuable feedback to creators and the platform itself, a basic analytics system will be implemented to track sharing activity.Implementation:When a user interacts with a share button (e.g., "Share to X," "Copy Link"), an event will be logged in the shares table. This record will capture the creation_id, the user_id of the sharer (if authenticated), and the target platform.To further enhance tracking, unique query parameters can be appended to the shared URL (e.g., ?utm_source=decollage_share&utm_medium=twitter&share_id=<unique_share_id>). This allows for more granular analysis of traffic sources and can help identify which platforms and which users are the most effective drivers of content virality. This data is invaluable for future feature development, such as creating leaderboards for the most-shared creations or identifying "super-sharer" users for community rewards.Feature Deep Dive: The Content Distribution ArchitectureThis section focuses on the on-site presentation of user-generated content, detailing the architecture for the automatically generated pages that form the core of the user experience.The Auto-Generated Page Template: "Galer铆a de Creaci贸n"Each public creation will have its own dedicated, permanent URL, structured as a dynamic route in Next.js (e.g., /c/[creationId]). This page serves as the "Galer铆a de Creaci贸n" and will be the primary destination for shared links and organic search traffic.Page Structure and Components:The page will be built as a server component in Next.js, fetching all necessary data for a given creationId from Supabase during the ISR process. It will be composed of several modular React components:CreatorHeader: Displays the creator's avatar, username, and the creation's title and timestamp.CreationShowcase: The main content area, featuring the interactive "Antes y Despu茅s" slider.CreationDetails: A section containing the user-provided description and any associated tags.EngagementPanel: A client-side component that includes the real-time "Aplausos" button and counter, along with the primary sharing buttons. This component will handle the subscription to Supabase Realtime.CallToActionFooter: A section encouraging visitors to create their own account and start their own projects on Decollage.cl.This component-based architecture ensures a clean separation of concerns, facilitates code reuse, and allows for easier maintenance and future enhancements.Dynamic Theming via Color Extraction: "Armon铆a Visual Autom谩tica"To realize the vision of "Cada Creaci贸n, una Galer铆a," each page must feel unique and visually tailored to the artwork it displays. This will be achieved through an innovative automated theming system that extracts a color palette from the user's final image and applies it to the page's UI elements.Technical Implementation:This process will be fully automated and triggered upon image upload.Trigger: A Supabase Edge Function will be invoked whenever a new row is inserted into the creations table.Image Processing: The Edge Function will receive the after_image_url. It will then fetch the image data from Supabase Storage.Color Extraction: The function will use a lightweight, server-side compatible JavaScript library like colorthief to analyze the image pixels.16 This library can efficiently identify the most prominent colors in an image. Alternative libraries such as extract-colors or @dominate-color.js/core also provide robust functionality for this task.18 The function will extract a palette of key colors, such as a dominant color, a vibrant accent, and a muted background color.Palette Storage: The extracted palette will be stored as a JSONB object in the color_palette column of the creations table. A typical palette might look like: {"primary": "#1A2B3C", "accent": "#D4AF37", "background": "#F5F5F5"}.Dynamic Styling: When the /c/[creationId] page is rendered via ISR, it fetches this color_palette object along with the other creation data. These color values are then injected into the page's root element as CSS custom properties (variables). For example: <main style="--theme-primary: #1A2B3C; --theme-accent: #D4AF37;">.Themed CSS: The page's stylesheet will be authored to use these CSS variables for key UI elements like button backgrounds, link colors, section borders, and text highlights. This allows the entire page's color scheme to adapt automatically and harmoniously to the user's artwork, creating a bespoke and professional-looking gallery page for every single creation.This feature is a significant differentiator, elevating the platform's perceived quality and providing a delightful experience that encourages users to share their beautifully presented work.Showcasing Transformation: The "Antes y Despu茅s" SliderThe core narrative of Decollage.cl is transformation. The most effective way to showcase this is with an interactive "Antes y Despu茅s" (Before and After) image comparison slider. This component allows visitors to engage directly with the content by sliding a divider to reveal the changes between the two images.Library Selection and Implementation:A well-maintained, lightweight, and accessible React component is essential for this feature. Based on community adoption, feature set, and performance, react-compare-slider is a strong candidate.20 It has zero dependencies, a small bundle size, and supports accessibility features like keyboard navigation. Other viable options include react-before-after-slider-component and react-compare-image.20The chosen component will be integrated into the CreationShowcase module. It will be configured to be fully responsive, adapting to the parent container's width, and will receive the before_image_url and after_image_url from the creation's data as props. The styling of the slider handle and divider will be customized to match the overall brand aesthetic of Decollage.cl.A Comprehensive SEO Implementation PlanEnsuring that every auto-generated creation page is highly discoverable by search engines is paramount to driving organic traffic and growth. The choice of ISR provides a solid foundation by serving pre-rendered HTML that is easily crawlable by bots.1 This will be augmented by a multi-faceted SEO strategy.Dynamic Metadata: The generateMetadata function in Next.js will be used within the dynamic page component (/c/[creationId]/page.tsx).11 This server-side function will fetch the specific creation's data (title, description, author's username) before the page is rendered and dynamically construct unique and descriptive metadata for each page.Title Tag: <title> por [Username] | Decollage.cl</title>Meta Description: <meta name="description" content="[First 155 characters of creation description]...">This ensures every page has unique, relevant metadata, which is a critical factor for search engine ranking.9Structured Data (JSON-LD): A <script type="application/ld+json"> tag will be embedded in the page's <head>. This script will contain structured data using the schema.org vocabulary, specifically the CreativeWork or ImageObject schema. It will programmatically include details like the author, title, a description, and the image URL. This helps search engines like Google understand the content and context of the page, significantly increasing the likelihood of appearing as a "rich snippet" in search results, which can dramatically improve click-through rates.9Canonical URLs: To prevent duplicate content issues, a canonical link tag (<link rel="canonical" href="...">) will be dynamically generated for each page. This tag will point to the definitive, clean URL for the creation (e.g., https://decollage.cl/c/123-abc), signaling to search engines that this is the master version of the page to index.10Sitemap Generation: An automated, server-side process will be implemented to generate and maintain a sitemap.xml file. This can be achieved using a library like next-sitemap or a custom script that runs periodically (e.g., via a cron job). The sitemap will list the URLs of all public creation pages, ensuring that search engine crawlers can efficiently discover and index all user-generated content, especially new additions.9robots.txt: A robots.txt file will be configured in the public directory to provide instructions to web crawlers, disallowing them from indexing non-public areas of the site (like user settings or admin panels) and providing the location of the sitemap.xml file.22The Complete Project BacklogThe following table translates the architectural and feature specifications into a prioritized, actionable project backlog. This backlog is structured using agile principles, with work organized into Epics and User Stories. Each story includes technical implementation notes tailored to the Next.js/Supabase/Cloudflare stack, providing a clear roadmap for the development team.IDEpicUser StoryAcceptance CriteriaTechnical Implementation NotesPriorityDependenciesFND-01Foundational SetupAs a Developer, I need a new Next.js project configured with the standard tech stack so I can begin development.- Next.js 14+ with App Router is initialized.
- TypeScript is configured.
- Tailwind CSS is set up for styling.
- ESLint and Prettier are configured for code quality.Use create-next-app with the recommended TypeScript and Tailwind CSS options. Establish base layout components.High-FND-02Foundational SetupAs a Developer, I need the Supabase project and initial database schema set up so that data persistence is available.- Supabase project is created.
- Database schema (users, creations, votes, shares) is defined in SQL files.
- Supabase CLI is used to apply initial migrations to the local and remote databases.Use supabase init. Create migration files in supabase/migrations/. Define tables, foreign keys, and RLS policies as per the architecture document.High-FND-03Foundational SetupAs a User, I want to sign up and log in using my email and password or a social provider so I can access the platform.- Users can register with email/password.
- Users can log in and log out.
- A users table profile is created upon new user registration via a Postgres trigger.
- At least one social provider (e.g., Google) is enabled.Use the Supabase Auth UI kit or build a custom form with the supabase-js client. Set up the handle_new_user trigger as per Supabase documentation.HighFND-02FND-04Foundational SetupAs a Platform Owner, I want the application deployed and served through Cloudflare for performance and security.- Next.js app is deployed (e.g., to Vercel).
- Domain DNS is managed by Cloudflare.
- Caching rules are configured for static assets.
- Basic security settings (WAF, SSL) are enabled.Point domain to Vercel/deployment target via Cloudflare proxy. Configure Page Rules in Cloudflare to cache static content aggressively.HighFND-01CD-01Content DistributionAs a Creator, I want to upload a 'before' and 'after' image and provide a title and description for my new creation.- A form allows users to select two image files.
- Images are uploaded to a private Supabase Storage bucket.
- A new record is created in the creations table with metadata and storage URLs.
- User is redirected to their new creation page upon success.Use Supabase Storage client library for uploads. Implement RLS on the storage bucket to allow authenticated users to upload.HighFND-03CD-02Content DistributionAs a Visitor, I want to view a creation on a unique, shareable page so I can see the details of the work.- A dynamic route /c/[creationId] exists.
- The page fetches data for the specific creation from Supabase.
- The page displays the title, description, and creator's info.
- The page is rendered using Incremental Static Regeneration (ISR).Create app/c/[creationId]/page.tsx. Use getStaticProps with a revalidate key. Fetch data using the Supabase client.HighCD-01CD-03Content DistributionAs a Platform Owner, I want a color palette automatically extracted from every new creation to enable dynamic theming.- A Supabase Edge Function is triggered on new creations table inserts.
- The function downloads the 'after' image.
- It extracts a 3-5 color palette.
- The palette is saved to the color_palette JSONB column.Use Deno and the colorthief library (or equivalent) in a Supabase Edge Function. Grant the function permissions to read Storage and write to the creations table.MediumCD-01CD-04Content DistributionAs a Visitor, I want the creation page to be visually themed based on the artwork's colors for a more beautiful experience.- The ISR page fetches the color_palette from the database.
- The colors are injected as CSS custom properties (--theme-primary, etc.) into the page's main container.
- The page's CSS uses these variables for styling.In the page component, read the color_palette object and apply it to a style attribute on a wrapper div. Author Tailwind CSS config or global CSS to use these variables.MediumCD-03CD-05Content DistributionAs a Visitor, I want to interact with an image slider to compare the 'before' and 'after' states of a creation.- The react-compare-slider component is integrated on the creation page.
- It correctly displays the before_image_url and after_image_url.
- The slider is responsive and works on mobile devices.Install react-compare-slider npm package. Pass the image URLs from the fetched creation data as props to the component.HighCD-02SS-01Social SharingAs a Platform Owner, I need a server-side mechanism to generate dynamic Open Graph images for social sharing.- An opengraph-image.tsx route handler is created in the /c/[creationId] directory.
- It fetches creation data based on the ID.
- It returns a valid image response.Use next/og's ImageResponse constructor. The function should be async to fetch data from Supabase.HighCD-02SS-02Social SharingAs a Designer, I need a branded React component that serves as the template for all OG images.- A React component (OGCard.tsx) is created.
- It accepts props like title, author, and image URL.
- The layout matches the brand's design specifications, using Flexbox for structure.Build the component using standard JSX and inline styles compatible with ImageResponse. Load custom fonts if necessary.HighSS-01SS-03Social SharingAs a Developer, I need to implement the "generate-once, cache-forever" strategy for OG images to ensure scalability.- A Supabase function is triggered on new creations.
- It calls an internal API to generate the OG image.
- The image is saved to Supabase Storage.
- The static URL is updated in the creations table.Create a Supabase Edge Function. Create a protected Next.js API route for image generation. The generateMetadata function should then use the og_image_url field.MediumSS-02UE-01User EngagementAs a Visitor, I want to see and click a button to give "Aplausos" to a creation I like.- A button with a clear icon/label for "Aplausos" is visible on the creation page.
- The current total count of "Aplausos" is displayed next to the button.
- Clicking the button triggers the voting logic.Create a client component for the button and counter. On click, call a server action or API route to record the vote.MediumCD-02UE-02User EngagementAs a Developer, I need the backend infrastructure to securely record user votes.- The votes table is created with a unique constraint on (creation_id, user_id).
- RLS policies are in place to only allow authenticated users to insert votes as themselves.
- An RPC function add_vote(creation_id) can be created for easier client-side calls.Write SQL for the table and RLS policies in a migration file. The unique constraint handles preventing duplicate votes.MediumFND-02UE-03User EngagementAs a Developer, I need to implement a real-time broadcast system for vote updates to avoid polling.- A Postgres trigger is created on the votes table for INSERT and DELETE.
- The trigger calls a function that uses realtime.broadcast_changes() on a channel like creations-votes:[id].
- The payload includes the new total vote count.Write the PL/pgSQL trigger function and attach it to the votes table in a migration. The function should calculate the new COUNT(*) for the creation.MediumUE-02UE-04User EngagementAs a Visitor, I want to see the "Aplausos" count update instantly when someone else votes, without refreshing the page.- The client-side engagement component subscribes to the Supabase Realtime channel for the current creation.
- It listens for broadcast events from the vote trigger.
- Upon receiving a new vote count, the component's state is updated, and the UI reflects the new number.Use the supabase-js client's .channel() and .on('broadcast',...) methods within a useEffect hook in the client component.MediumUE-03SEO-01SEO & PerformanceAs a Search Engine, I want to find unique and descriptive title and description metadata for every creation page.- The generateMetadata function is implemented in the creation page component.
- It dynamically generates <title> and <meta name="description"> tags based on the creation's data.
- Metadata is unique for each creation.Implement the export async function generateMetadata({ params }) in page.tsx. Fetch data from Supabase within this function.HighCD-02SEO-02SEO & PerformanceAs a Search Engine, I want to find structured data (JSON-LD) on creation pages to better understand the content.- A JSON-LD <script> tag is included in the page's head.
- It uses the CreativeWork schema from schema.org.
- It is populated with dynamic data like author, title, and image URL.Generate the JSON object within the page component and serialize it into a string to be placed inside the script tag.MediumCD-02SEO-03SEO & PerformanceAs a Search Engine, I need an up-to-date sitemap to discover all public creation pages efficiently.- A sitemap.xml file is generated and available at the site root.
- The sitemap includes all public URLs from the creations table.
- The sitemap is regenerated periodically to include new content.Use the next-sitemap package and configure it to run post-build, or create a serverless function that generates it on a schedule and caches the result.MediumCD-02Future Vision: The "Momentos M谩gicos" AI SuiteTo establish Decollage.cl as an innovative leader and create new monetization opportunities, a roadmap for premium, AI-powered features is proposed. These features, initially marketed under the "Momentos M谩gicos" (Magic Moments) banner and marked as "Pr贸ximamente" (Coming Soon), will provide creators with powerful new tools to showcase their work.Concept: AI-Generated Video Shorts from CreationsThe flagship feature of the "Momentos M谩gicos" suite will be the one-click generation of short, dynamic videos from a user's static 'before' and 'after' images.User Value Proposition: "Transforma tu creaci贸n est谩tica en un video corto y din谩mico, perfecto para compartir en Reels, TikTok y Stories." (Transform your static creation into a short, dynamic video, perfect for sharing on Reels, TikTok, and Stories.)This feature addresses the growing demand for video content on social media. It empowers users who may lack video editing skills to create engaging, professional-looking animations that highlight their creative process. The generated video (e.g., 5-8 seconds) could feature cinematic effects like a slow pan, a crossfade reveal, or an animated slider effect, complete with a title card and a branded Decollage.cl outro.Technical Feasibility & Recommended Approach: RemotionWhile various AI video generation APIs exist, such as Google's Veo 3, they are primarily designed for text-to-video generation and offer limited control over the final output's branding, animation, and structure.23 For this specific use case, a programmatic video creation framework provides the necessary precision and control.Recommendation: RemotionRemotion is the ideal technology for this feature as it allows developers to create videos programmatically using React.25 This aligns perfectly with the existing technology stack and the development team's skillset. With Remotion, video templates are simply React components that can be parameterized and rendered on a server.26Implementation Plan:Template Development: The team will develop a series of Remotion <Composition> components. Each composition will be a different video template (e.g., "Fade Reveal," "Wipe Transition," "Ken Burns Effect"). These components will be designed to accept props, such as the before_image_url, after_image_url, title, and even the color_palette to ensure the video's theme matches the creation's page.27Server-Side Rendering Infrastructure: A server-side rendering environment for Remotion will be established. This can be a dedicated Node.js server or, for better scalability, a serverless architecture using Remotion Lambda on AWS.28User Flow: A premium user will click a "Crear Video M谩gico" button on their creation page. This action will trigger a request to the backend.Rendering Process: The backend will queue a rendering job, passing the creation's data to the Remotion rendering engine. The engine will programmatically render the chosen React video template frame-by-frame into a final MP4 file.29Delivery: The completed MP4 video will be uploaded to Supabase Storage. The user will be notified when their video is ready, and a link to download or share the video will be provided.Phased Rollout StrategyA phased approach will be used to launch this premium feature, allowing for iterative development, feedback collection, and anticipation building.Phase 1 (Post-MVP Launch): A disabled button or a promotional banner for "Momentos M谩gicos" will be added to the creation page UI, labeled "Pr贸ximamente." This will gauge user interest and build excitement for the upcoming feature.Phase 2 (Closed Beta): A single, polished Remotion video template will be developed. The feature will be enabled for a select group of power users or early adopters. Their feedback on video quality, style, and overall experience will be invaluable for refinement.Phase 3 (Public Launch): The feature will be launched publicly as a premium offering. This could be part of a new subscription tier ("Creator Pro") or available as a one-time purchase per video render. Based on the success and feedback from the initial launch, additional video templates and customization options will be developed to expand the "Momentos M谩gicos" suite.Appendix: Lexicon for Decollage.clThis appendix provides a centralized dictionary of user-facing text, notifications, and labels. The copy is crafted in authentic Chilean Spanish to ensure a consistent, professional, and culturally resonant brand voice across the entire platform.KeyContexto de UsoTipoTexto en Espa帽ol Chilenotitle.galleryT铆tulo principal de la p谩gina de una creaci贸n.TitleGaler铆a de Creaci贸ntitle.homeT铆tulo de la p谩gina principal.TitleInsp铆rate y Creabutton.shareBot贸n principal para compartir en la p谩gina de creaci贸n.ButtonCompartirbutton.voteBot贸n para dar una reacci贸n a una creaci贸n.ButtonAplaudirbutton.uploadBot贸n para iniciar el proceso de subir una nueva creaci贸n.ButtonCrear Nuevo Proyectobutton.createVideoBot贸n (inicialmente deshabilitado) para la funci贸n de video AI.ButtonCrear Video M谩gicolabel.beforeEtiqueta para la imagen 'antes' en el slider.LabelAnteslabel.afterEtiqueta para la imagen 'despu茅s' en el slider.LabelDespu茅slabel.votes.singularTexto junto al contador de votos cuando hay 1 voto.Label1 Aplausolabel.votes.pluralTexto junto al contador de votos cuando hay m谩s de 1 voto.Label{count} Aplausoslabel.byAuthorPrefijo para el nombre del autor de la creaci贸n.LabelPor {username}label.comingSoonEtiqueta para funciones futuras.LabelPr贸ximamentetooltip.shareTooltip que aparece al pasar el mouse sobre el bot贸n de compartir.Tooltip隆Muestra tu talento al mundo!tooltip.voteTooltip que aparece al pasar el mouse sobre el bot贸n de aplaudir.Tooltip隆Demuestra tu aprecio por esta creaci贸n!notification.linkCopiedMensaje de confirmaci贸n cuando se copia un enlace.Notification隆Enlace copiado! Listo para pegar y compartir.notification.voteSuccessMensaje de confirmaci贸n despu茅s de votar.Notification隆Gracias por tu aplauso!error.uploadFailedMensaje de error si falla la subida de una imagen.Error Message隆Upa! Hubo un problema al subir tu imagen. Por favor, int茅ntalo de nuevo.error.notLoggedInMensaje que pide al usuario iniciar sesi贸n para realizar una acci贸n.Error MessagePara aplaudir, necesitas iniciar sesi贸n.form.title.placeholderPlaceholder para el campo de t铆tulo en el formulario de subida.Form PlaceholderDale un t铆tulo a tu obra maestraform.description.placeholderPlaceholder para el campo de descripci贸n.Form PlaceholderCu茅ntanos un poco sobre tu proceso creativo...